from __future__ import annotations

from dataclasses import dataclass, field
from typing import Iterable, List, Literal, Optional, Tuple

CoordType = Literal["reciprocal", "cartesian", "fractional"]
ModeType = Literal["automatic", "length", "explicit", "line"]


@dataclass
class Kpoints_generator:
    mode: ModeType

    comment: str = "KPOINTS generated by Kpoints"

    # automatic mesh
    mesh: Optional[Tuple[int, int, int]] = None
    shift: Tuple[int, int, int] = (0, 0, 0)
    scheme: str = "Gamma"  # "G", "Gamma", "Monkhorst-Pack", "Auto", ...

    # length-based automatic
    length: Optional[float] = None

    # explicit list
    coord_type: CoordType = "reciprocal"
    kpts: List[Tuple[float, float, float]] = field(default_factory=list)
    weights: List[float] = field(default_factory=list)

    # line mode
    line_divisions: int = 0
    segments: List[
        Tuple[
            Tuple[float, float, float],
            str,  # k_start, label_start
            Tuple[float, float, float],
            str,  # k_end,   label_end
        ]
    ] = field(default_factory=list)

    # ---------- constructors ----------

    @classmethod
    def automatic_mesh(
        cls,
        mesh: Tuple[int, int, int],
        scheme: str = "Gamma",
        comment: str = "Automatic mesh",
        shift: Tuple[int, int, int] = (0, 0, 0),
    ) -> "Kpoints_generator":
        return cls(
            mode="automatic",
            mesh=mesh,
            shift=shift,
            scheme=scheme,
            comment=comment,
        )

    @classmethod
    def automatic_length(
        cls,
        length: float,
        scheme: str = "Auto",
        comment: str = "Automatic length mesh",
    ) -> "Kpoints_generator":
        # VASP "Auto" length-based mesh: 0 / Auto / length
        return cls(
            mode="length",
            length=length,
            scheme=scheme,
            comment=comment,
        )

    @classmethod
    def explicit(
        cls,
        kpts: Iterable[Tuple[float, float, float]],
        weights: Optional[Iterable[float]] = None,
        coord_type: CoordType = "reciprocal",
        comment: str = "Explicit k-points",
    ) -> "Kpoints_generator":
        kpts_list = list(kpts)
        if weights is None:
            weights_list = [1.0] * len(kpts_list)
        else:
            weights_list = list(weights)
            if len(weights_list) != len(kpts_list):
                raise ValueError("len(weights) must match len(kpts)")
        return cls(
            mode="explicit",
            kpts=kpts_list,
            weights=weights_list,
            coord_type=coord_type,
            comment=comment,
        )

    @classmethod
    def line_mode(
        cls,
        segments: Iterable[
            Tuple[
                Tuple[float, float, float],
                str,
                Tuple[float, float, float],
                str,
            ]
        ],
        divisions: int = 40,
        coord_type: CoordType = "fractional",
        comment: str = "Line mode",
    ) -> "Kpoints_generator":
        return cls(
            mode="line",
            segments=list(segments),
            line_divisions=divisions,
            coord_type=coord_type,
            comment=comment,
        )

    # ---------- formatting ----------

    def to_string(self) -> str:
        if self.mode == "automatic":
            if self.mesh is None:
                raise ValueError("mesh must be set for automatic mode")
            nx, ny, nz = self.mesh
            sx, sy, sz = self.shift
            lines = [
                "KPOINTS",
                self.comment,
                "0",
                self.scheme,
                f"{nx} {ny} {nz}",
                f"{sx} {sy} {sz}",
            ]
            return "\n".join(lines) + "\n"

        # length-based automatic: 0 + Auto + length
        if self.mode == "length":
            if self.length is None:
                raise ValueError("length must be set for length mode")
            lines = [
                "KPOINTS",
                self.comment,
                "0",
                self.scheme,  # typically "Auto"
                f"{self.length:g}",
            ]
            return "\n".join(lines) + "\n"

        if self.mode == "explicit":
            n = len(self.kpts)
            coord_line = {
                "reciprocal": "Reciprocal",
                "fractional": "Reciprocal",  # VASP uses reciprocal lattice fractions
                "cartesian": "Cartesian",
            }[self.coord_type]

            lines = [
                "KPOINTS",
                self.comment,
                str(n),
                "Explicit",  # label; VASP mainly cares about next line
                coord_line,
            ]
            for (kx, ky, kz), w in zip(self.kpts, self.weights):
                lines.append(f"{kx: .8f} {ky: .8f} {kz: .8f} {w: .8f}")
            return "\n".join(lines) + "\n"

        if self.mode == "line":
            coord_line = {
                "fractional": "fractional",
                "reciprocal": "reciprocal",
                "cartesian": "cartesian",
            }[self.coord_type]

            lines = [
                "KPOINTS",
                self.comment,
                str(self.line_divisions),
                "line mode",
                coord_line,
            ]

            first = True
            for k1, lab1, k2, lab2 in self.segments:
                if not first:
                    lines.append("")  # blank line between segments
                first = False
                x1, y1, z1 = k1
                x2, y2, z2 = k2
                lines.append(f"  {x1: .8f} {y1: .8f} {z1: .8f}   {lab1}")
                lines.append(f"  {x2: .8f} {y2: .8f} {z2: .8f}   {lab2}")

            return "\n".join(lines) + "\n"

        raise ValueError(f"Unknown mode: {self.mode}")

    def __str__(self) -> str:  # so str(kpoints_obj) gives the file
        return self.to_string()
